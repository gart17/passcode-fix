#ifndef BLOCK_LINEAR
#define BLOCK_LINEAR

#include <cstdio>
#include <vector>
#include <string>
#include <cstring>
#include "linear.h"

using namespace std;

void myfread(void *ptr, size_t size, size_t nmemb, FILE * stream);
int myuncompress(void *dest, size_t *destlen, const void *source, size_t sourcelen);

enum {BINARY, COMPRESSION}; // data format
class binaryfmt_problem
{
	public:
		int l, n;
		binaryfmt_problem(): l(0), n(0), buf(NULL), buflen(0), cache_offset(0), bias_idx(-1), bias(-1){}
		~binaryfmt_problem(){ if(buflen>0) free(buf);}

		void set_bias(int idx, double val, int datafmt = COMPRESSION);

		// load and transfer problem contents from "filename" to internal
		void load_problem(const char* filename, int datafmt);

		// return self as a (problem*) prob
		struct problem* get_problem();

		// store cached sample in memory
		int move_cached_samples(struct problem *subprob, int *cache_index, unsigned long max_cache_memory);

		// allocate memory to store data used in solving the sub-problem
		void allocate_buf(unsigned long buflen);

	private:
		unsigned char* buf;
		size_t buflen, n_x_space, filelen, cache_offset;
		int bias_idx;
		double bias;
		struct feature_node* x_space;
		struct problem prob, retprob;

		void load_header(FILE *fp);
		void load_body(FILE *fp, int datafmt);
		void parse_binary();
};

class block_problem
{
	public:
		int nBlocks, n, l, nr_class;
		int datafmt;
		unsigned long max_buflen;
		double bias;
		vector<string> binary_files;
		vector<int> start;
		vector<int> subl;
		vector<int> label;
		binaryfmt_problem prob_;

		block_problem(): n(0), l(0), datafmt(-1), bias(-1){}
		void set_bias(double b);

		// Read a directory generated by blockspliter
		void read_metadata(const char* dirname);

		// Get the (problem*) prob of the specified block
		struct problem* get_block(int id);

		// Generate (block_problem) problem according to blocklist
		block_problem gen_sub_problem(const vector<int>& blocklist);

		// store cached samples in memory
		int move_cached_samples(struct problem *subprob, int *cache_index, unsigned long max_cache_memory);
};


void block_solve_l2r_l1l2_svc(block_problem *bprob, const parameter *param, double *w, double Cp, double Cn);
void block_train_MCSVM_CS(block_problem *bprob, const parameter *param, double *w, int nr_class, double *weighted_C);
void block_solve_l2r_lr_dual(block_problem *bprob, const parameter *param, double *w, double Cp, double Cn);
struct model* block_train(block_problem* bprob, const  parameter* param);

// Return #correct
double block_testing(struct model* model_, block_problem *bprob);
double block_cross_validation(block_problem *bprob, const parameter *param, int nr_fold);
const char *block_check_parameter(const block_problem *bprob, const parameter *param);

#endif
